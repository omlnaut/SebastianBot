# When creating a new service (usecase), follow these instructions:
- put into usecases dir, each usecase in its own folder
- create a service.py file containing the service class
- services orchestrate clients and business logic
- services should:
    - accept clients via dependency injection in __init__
    - return Result[T] for operations that can fail
    - return plain types (list, objects) for operations that always succeed
    - extract domain models in a models.py (pydantic models if parsing is involved, dataclasses otherwise)
    - extract parsing/transformation/logic into separate files if complex
- services must not depend on cloud/infrastructure layer (Azure functions, etc.)
- follow naming convention: {UseCase}Service (e.g., DeliveryReadyService, MangaUpdateService)
- when creating from a notebook: add a section that showcases the usage of the service
- add service resolver in cloud/dependencies/services.py (injecting required clients)
- when creating a new service, also create a notebook showcasing the usage. if a notebook alreaddy exists for the service, add to that one instead
- make configuration values, such as time-based thresholds, parameters to the public methods
    - use `timedelta` for any time span arguments (e.g. instead of `hours_back: int`, prefer `time_back: timedelta`)
